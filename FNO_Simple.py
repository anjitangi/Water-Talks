# -*- coding: utf-8 -*-
"""Copy of FourierNeuralOperator_AnjaliTangirala.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z2dKhrtT_RinxdmI_6Xw4K9XVc0B6OnN

# Fourier Neural Operator for Parametric Partial Differential Equations
### Deep Learning Final Presentation
#### Anjali Tangirala

## Preprocessing the Data
The code below uses OpenCV for video processing and PyTorch for tensor operations. It is implemented to compute optical flows between consecutive frames of a video, representing the motion vectors of pixels between frames. The script includes adjustments to the contrast and brightness of the frames and apply thresholding before computing the flow. Optional HSV and Grayscale parameters were experimented with in preprocessing to optimize vector extraction. After preprocessing, the script calculates the optical flow using OpenCV's calcOpticalFlowFarneback method, which is saved and converted into PyTorch tensors. These tensors, representing the sequence of flow fields, were intended to be used as inputs and labels for training the model, to predict future states in a video sequence. The code also crops frames to focus on specific regions, enhancing the model's focus on relevant motion details.
"""

import cv2
import numpy as np
import torch
import torch.optim as optim
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader, TensorDataset
from google.colab.patches import cv2_imshow

def adjustImage(frame, mode, contrastBool, threshBool,
                upperThresh, lowerThresh, contrast, brightness):
    if mode == 'HSV':
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        if contrastBool:
            hsv[:,:,2] = cv2.convertScaleAbs(hsv[:,:,2], alpha=contrast, beta=brightness)
        if threshBool:
            _, hsv[:,:,2] = cv2.threshold(hsv[:,:,2], lowerThresh, upperThresh, cv2.THRESH_BINARY)
        processed_img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
        processed_img = cv2.cvtColor(processed_img, cv2.COLOR_BGR2GRAY)
    elif mode == 'Gray':
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        if contrastBool:
            gray = cv2.convertScaleAbs(gray, alpha=contrast, beta=brightness)
        if threshBool:
            _, gray = cv2.threshold(gray, lowerThresh, upperThresh, cv2.THRESH_BINARY)
        processed_img = gray
    else:
        raise ValueError("Mode should be 'HSV' or 'Gray'.")

    return processed_img

video_path = '/content/vecteezy_snow-falling-background_1623412.mp4'
mode = "Gray"
contrastBool = True
threshBool = True
lowerThresh = 0
upperThresh = 250
contrast = 2
brightness = 100

cap = cv2.VideoCapture(video_path)
ret, frame = cap.read()
cv2_imshow(frame)

new_frame = adjustImage(frame, mode, contrastBool, threshBool, upperThresh, lowerThresh, contrast, brightness)
cv2_imshow(frame)

def extract_and_compute_flows(video_path, mode, contrastBool, threshBool, upperThresh, lowerThresh, contrast, brightness):
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print(f"Failed to open video: {video_path}")
        exit()
    ret, prev_frame = cap.read()
    prev_frame = adjustImage(prev_frame, mode, contrastBool, threshBool, upperThresh, lowerThresh, contrast, brightness)
    prev_frame = prev_frame[0:1200, 675:1250]

    vector_data = []
    vector_labels = []

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # current_frame = adjustImage(frame, mode, contrastBool, threshBool, upperThresh, lowerThresh, contrast, brightness)
        current_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        current_frame = current_frame[0:1200, 675:1250]

        flow = cv2.calcOpticalFlowFarneback(prev_frame, current_frame, None, 0.5, 3, 15, 3, 5, 1.2, 0)
        vector_data.append(flow)

        prev_frame = current_frame

    vector_data_np = np.array(vector_data)
    vector_data_tensor = torch.tensor(vector_data_np)
    vector_labels_tensor = vector_data_tensor[1:]

    cap.release()
    return vector_data_tensor[:-1], vector_labels_tensor

data, labels = extract_and_compute_flows(video_path, mode, contrastBool, threshBool, upperThresh, lowerThresh, contrast, brightness)

data = data.permute(0, 3, 1, 2)  # [n_samples, 2, height, width]
labels = labels.permute(0, 3, 1, 2)

# Take a smaller portion of the dataset (otherwise it's 5 GB...)
num_samples = data.shape[0] // 11

data = data[:num_samples]
labels = labels[:num_samples]

"""# Neural Network Model

The model below defines an architecture for processing 3D video and 2D spatial data using PyTorch, featuring several types of neural network layers, including convolutional, Fourier, and fully connected layers. The core of the architecture is a FNO3d class that uses a downsampling convolutional neural network (DownsampleCNN) to reduce the spatial dimensionality of the input data, followed by four FourierLayer modules that perform operations in the Fourier space to learn complex patterns effectively. The Fourier layers use a combination of rapid Fourier transforms and learned linear transformations to manipulate the data in the frequency domain, before it is transformed back to the spatial domain. The entire sequence is encapsulated within a 2D and 3D version of a Fourier Neural Operator (FNO), designed to handle three-dimensional and two-dimensional data efficiently. The cell includes functions for data normalization and batch processing incorporating data loaders to ensure inputs are standardized. The model is compiled with a loss function and optimizer for training. The code leverages CUDA if GPU's are available, for accelerated computations.

### 2D Fourier Neural Operator (Spatial Dimension)
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader, TensorDataset
from torch.profiler import profile, record_function, ProfilerActivity
import traceback
import os

def standardize_data(data):
    mean = data.mean(dim=(0, 2, 3), keepdim=True)
    std = data.std(dim=(0, 2, 3), keepdim=True)

    normalized_data = (data - mean) / std
    return normalized_data

def normalize_batch(batch):
    data_list = [item[0] for item in batch]
    labels_list = [item[1] for item in batch]

    data = torch.stack(data_list)
    labels = torch.stack(labels_list)

    normalized_data = standardize_data(data)
    return normalized_data, labels

class DownsampleCNN(nn.Module):
    def __init__(self):
        super(DownsampleCNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 16, kernel_size=3, stride=2, padding=1)  # output size: (540, 288)
        self.pool1 = nn.MaxPool2d(2, 2)  # output size: (270, 144)

        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, stride=2, padding=1)  # output size: (135, 72)
        self.pool2 = nn.MaxPool2d(2, 2)  # output size: (68, 36)

        self.conv3 = nn.Conv2d(32, 1, kernel_size=5, stride=1, padding=0)

    def forward(self, x):
        outputs = []
        for i in range(x.shape[1]):
            out = F.relu(self.conv1(x[:, i:i+1, :, :]))
            out = self.pool1(out)
            out = F.relu(self.conv2(out))
            out = self.pool2(out)
            out = self.conv3(out)
            outputs.append(out)

            if outputs[i].size(2) == 63:
                outputs[i] = F.pad(outputs[i], (0, 0, 0, 1))

        return torch.cat(outputs, dim=1)

class FourierLayer(nn.Module):
    def __init__(self, in_channels, out_channels, modes1, modes2):
        super().__init__()
        self.scale = (1 / (in_channels * out_channels))
        #Generating FourierLayer weights for  highest and lowest spectral frequencies
        self.weights1 = nn.Parameter(self.scale * torch.randn(in_channels, out_channels, modes1, modes2, dtype=torch.cfloat))
        self.weights2 = nn.Parameter(self.scale * torch.randn(in_channels, out_channels, modes1, modes2, dtype=torch.cfloat))
        self.modes1 = modes1
        self.modes2 = modes2

        self.local_transform = nn.Linear(in_channels * 64 * 32, out_channels * 64 * 32)

    def forward(self, x):
        x_ft = torch.fft.rfft2(x)
        out_ft = torch.zeros_like(x_ft, dtype=torch.cfloat)
        #bixy,ioxy->boxy s.t. b=batch size, i = input channels , o = output channels, x,y = spatial dimensions
        out_ft[:, :, :self.modes1, :self.modes2] = torch.einsum("bixy,ioxy->boxy", x_ft[:, :, :self.modes1, :self.modes2], self.weights1)
        out_ft[:, :, -self.modes1:, :self.modes2] = torch.einsum("bixy,ioxy->boxy", x_ft[:, :, -self.modes1:, :self.modes2], self.weights2)

        x_ifft = torch.fft.irfft2(out_ft, s=(x.size(2), x.size(3)))

        #print("Fourier Local Linear Transform")
        x_flattened = x.view(x.shape[0], -1)
        x_local = self.local_transform(x_flattened)
        x_local = x_local.view(x.shape[0],32, x.size(2), x.size(3))

        output = x_ifft + x_local

        return output

class FNO2d(nn.Module):
    def __init__(self, in_channels, out_channels, modes1, modes2, height, width):
        super(FNO3d, self).__init__()
        self.downsample = DownsampleCNN()

        downsampled_height = 64
        downsampled_width = 32

        self.fc0 = nn.Linear(in_channels * downsampled_height * downsampled_width, 32 * downsampled_height * downsampled_width)
        self.fourier_layers = nn.ModuleList([FourierLayer(32, 32, modes1, modes2) for _ in range(4)])
        self.fc1 = nn.Linear(32 * downsampled_height * downsampled_width, out_channels * downsampled_height * downsampled_width)

    def forward(self, x):
        #print("Downsampling")
        x = self.downsample(x)
        batch_size, channels, height, width = x.shape

        x = x.contiguous().view(batch_size, channels * height * width)
        #print("First Linear Layer")
        x = F.gelu(self.fc0(x))

        x = x.view(batch_size, 32, height, width)

        for layer in self.fourier_layers:
            #print("Fourier Layer")
            x = F.gelu(layer(x))

        x = x.view(batch_size, -1)
        #print("Final Linear Layer")
        x = self.fc1(x)
        #print("Training done")
        x = x.view(batch_size, out_channels, height, width)

        return x

# parameters
in_channels = 2
out_channels = 2
modes1, modes2 = 12, 12

height = data.shape[2]
width = data.shape[3]

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = FNO2d(in_channels, out_channels, modes1, modes2, height, width).to(device)
optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)
criterion = nn.MSELoss()

"""### 3D Fourier Neural Operator (Temporal and Spatial Dimension)"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.transforms.functional as TF

class DownsampleCNN3D(nn.Module):
    def __init__(self, input_channels=2):
        super(DownsampleCNN3D, self).__init__()
        self.conv1 = nn.Conv3d(input_channels, 16, kernel_size=(1, 3, 3), stride=(1, 2, 2), padding=(0, 1, 1))
        self.pool1 = nn.MaxPool3d((1, 2, 2), stride=(1, 2, 2))
        self.conv2 = nn.Conv3d(16, 32, kernel_size=(1, 3, 3), stride=(1, 2, 2), padding=(0, 1, 1))
        self.pool2 = nn.MaxPool3d((1, 2, 2), stride=(1, 2, 2))
        self.conv3 = nn.Conv3d(32, input_channels, kernel_size=(1, 5, 5), stride=1, padding=(0, 0, 0))

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = self.conv3(x)
        if x.size(3) == 63:
            x = F.pad(x, (0, 0, 0, 1, 0, 0))
        return x

class FourierLayer3D(nn.Module):
    def __init__(self, in_channels, out_channels, modes1, modes2, modes3):
        super(FourierLayer3D, self).__init__()
        self.scale = (1 / (in_channels * out_channels))
        self.weights1 = nn.Parameter(self.scale * torch.randn(in_channels, out_channels, modes1, modes2, modes3, dtype=torch.cfloat))
        self.weights2 = nn.Parameter(self.scale * torch.randn(in_channels, out_channels, modes1, modes2, modes3, dtype=torch.cfloat))
        self.modes1 = modes1
        self.modes2 = modes2
        self.modes3 = modes3

        self.local_transform = nn.Linear(in_channels * 64 * 32 * 4, out_channels * 64 * 32 * 4)

    def forward(self, x):
        x_ft = torch.fft.rfftn(x, dim=[2, 3, 4])
        out_ft = torch.zeros_like(x_ft, dtype=torch.cfloat)

        out_ft[..., :self.modes1, :self.modes2, :self.modes3] = torch.einsum(
            "bixyz,ioxyz->boxyz",
            x_ft[..., :self.modes1, :self.modes2, :self.modes3],
            self.weights1)

        out_ft[..., -self.modes1:, :self.modes2, :self.modes3] = torch.einsum(
            "bixyz,ioxyz->boxyz",
            x_ft[..., -self.modes1:, :self.modes2, :self.modes3],
            self.weights2)

        x_ifft = torch.fft.irfftn(out_ft, s=x.shape[2:], dim=[2, 3, 4])

        x_flattened = x.view(x.shape[0], -1)
        x_local = self.local_transform(x_flattened)
        x_local = x_local.view(x.shape[0], -1, x.shape[2], x.shape[3], x.shape[4])

        output = x_ifft + x_local

        return output

class FNO3d(nn.Module):
    def __init__(self, in_channels, out_channels, modes1, modes2, modes3, time, height, width):
        super(FNO3d, self).__init__()
        self.downsample = DownsampleCNN3D(input_channels=2)

        downsampled_time = 4
        downsampled_height = 64
        downsampled_width = 32

        self.fc0 = nn.Linear(in_channels * downsampled_time * downsampled_height * downsampled_width, 10 * downsampled_time * downsampled_height * downsampled_width)
        self.fourier_layers = nn.ModuleList([FourierLayer3D(10, 10, modes1, modes2, modes3) for _ in range(4)])
        self.fc1 = nn.Linear(10 * downsampled_time * downsampled_height * downsampled_width, out_channels * 1 * downsampled_height * downsampled_width)

    def forward(self, x):
        print("Downsampling")
        x = self.downsample(x)
        batch_size, channels, depth, height, width = x.shape

        x = x.contiguous().view(batch_size, channels * depth * height * width)
        print("First Fully Connected Layer")
        x = F.gelu(self.fc0(x))
        x = x.view(batch_size, 10, depth, height, width)

        for layer in self.fourier_layers:
            print("Fourier Layer")
            x = F.gelu(layer(x))

        x = x.view(batch_size, -1)
        print("Final Fully Connected Layer")
        x = self.fc1(x)
        x = x.view(batch_size, 2, 1, height, width)

        return x

"""# Training the Network

The cell of code below shows the training process of the network, applying normalization, downsampling and data loading to both input data and labels. The TensorDataset and DataLoader handle data iteration with shuffling and batch normalization. Training spans 10 epochs, where each batch undergoes padding before being processed by the model in order to ensure the output dimensionality of 64 by 32 after downsampling.  The model’s predictions are then compared against normalized and downsampled target fields to compute loss, which updates the model parameters via backpropagation. Additionally, statistics like mean and standard deviation of the outputs are collected across batches for analysis after training.
"""

tensor_dataset = TensorDataset(data, labels)
data_loader = DataLoader(tensor_dataset, batch_size=2,shuffle=True, collate_fn=normalize_batch)
label_mean = labels.mean()
label_std = labels.std()

def normalize_labels(labels):
    return (labels - label_mean) / label_std

output_means = []
output_stds = []

downsampler = DownsampleCNN()
padding = (0, 1, 0, 0)

for epoch in range(10):
    epoch_loss = 0
    sample = 1
    for velocity_field, target_field in data_loader:
        y_vector_field_padded = F.pad(velocity_field, padding)
        target_field_padded = F.pad(target_field, padding)
        #print(f"Shape of vector field before training: {y_vector_field_padded.shape}")

        optimizer.zero_grad()

        output = model(velocity_field)

        output_means.append(output.mean(dim=(0, 2, 3)))  # batch, height, and width
        output_stds.append(output.std(dim=(0, 2, 3)))

        #print("Downsampling Target Field")
        target_field_downsampled = downsampler(target_field)
        norm_target_field = normalize_labels(target_field_downsampled)
        #print("Calculating Loss")
        #print(f"Output Shape: {output.shape}, Target Shape: {norm_target_field.shape}")
        loss = criterion(output, norm_target_field)
        loss.backward()
        optimizer.step()

        epoch_loss += loss.item()

        print(f"Training {sample}: Loss = {loss.item()}")
        sample += 1

    print(f"Epoch {epoch}: Loss = {epoch_loss / len(data_loader)}")

output_mean = torch.stack(output_means).mean(dim=0)
output_std = torch.stack(output_stds).mean(dim=0)

"""# Post-Training Analysis

The post training analysis procedure was necessary for evaluating the model's performance on the data, particularly in its image reconstruction and segmentation capabilities.The following code iterates over less than 100 batches of the input data, ensures GPU usage, and model prediction without weight updating(torch.no_grad()) and predicts the output of a given piece of input data. It then resizes both the outputs and the corresponding target fields to the original spatial dimensions (1080x575 pixels) using Lanczos interpolation. Finally, they are converted into NumPy arrays, and prepared for heatmap animation and vector field animation in order to compare labels with predictions in sequential form.
"""

import torch
import cv2
import numpy as np

model.eval()

predictions = []
original_labels = []

with torch.no_grad():
    for i, (velocity_field, target_field) in enumerate(data_loader):
        if i >= 100:
            break
        output = model(velocity_field.to(device))

        output_renorm = (output * output_std[0]) + output_mean[0]

        resized_outputs = []
        resized_targets = []

        for batch_index in range(output_renorm.shape[0]):
            resized_channels = []
            resized_target_channels = []

            for channel_index in range(output_renorm.shape[1]):
                channel_output = output_renorm[batch_index, channel_index, :, :].cpu().numpy()
                resized_output = cv2.resize(channel_output, (1080, 575), interpolation=cv2.INTER_LANCZOS4)
                resized_channels.append(resized_output)

                channel_target = target_field[batch_index, channel_index, :, :].cpu().numpy()
                resized_target = cv2.resize(channel_target, (1080, 575), interpolation=cv2.INTER_LANCZOS4)
                resized_target_channels.append(resized_target)

            resized_outputs.append(np.stack(resized_channels, axis=0))
            resized_targets.append(np.stack(resized_target_channels, axis=0))

        predictions.extend(resized_outputs)
        original_labels.extend(resized_targets)

predictions_np = np.array(predictions)
original_labels_np = np.array(original_labels)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
import cv2

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
cmap = 'hot'

pred_img = ax1.imshow(predictions_np[0, 0], cmap=cmap)
label_img = ax2.imshow(original_labels_np[0, 0], cmap=cmap)
ax1.title.set_text('Prediction')
ax2.title.set_text('Label')

def update(frame_number):
    if frame_number < predictions_np.shape[0]:
        min_val = min(np.min(predictions_np[frame_number, 0]), np.min(original_labels_np[frame_number, 0]))
        max_val = max(np.max(predictions_np[frame_number, 0]), np.max(original_labels_np[frame_number, 0]))

        scaled_predictions = 255 * (predictions_np[frame_number, 0] - min_val) / (max_val - min_val)
        scaled_labels = 255 * (original_labels_np[frame_number, 0] - min_val) / (max_val - min_val)

        scaled_predictions = predictions_np[frame_number, 0] * 200
        np.clip(scaled_predictions, 0, 255, out=scaled_predictions)

        scaled_labels = original_labels_np[frame_number, 0]
        np.clip(scaled_labels, 0, 255, out=scaled_labels)

        pred_img.set_data(scaled_predictions)
        label_img.set_data(scaled_labels)

    return pred_img, label_img

ani = FuncAnimation(fig, update, frames=min(100, predictions_np.shape[0]), blit=True, interval=1000)

writer = PillowWriter(fps=15)

ani.save('heatmap_animation.gif', writer=writer)

plt.show()

def draw_flows(img, pred_flow, label_flow, step=16):
    h, w = img.shape[:2]
    w2 = w // 2
    y, x = np.mgrid[step/2:h:step, step/2:w2:step].reshape(2,-1).astype(int)
    pred_fx, pred_fy = pred_flow[y,x].T
    label_fx, label_fy = label_flow[y,x].T

    mask = np.ones_like(img) * 255

    for (xx, yy, u, v) in zip(x, y, pred_fx, pred_fy):
        cv2.line(mask, (xx, yy), (int(xx + u), int(yy + v)), (0, 0, 255), 2)
        cv2.circle(mask, (xx, yy), 1, (0, 255, 0), -1)

    for (xx, yy, u, v) in zip(x + w2, y, label_fx, label_fy):
        cv2.line(mask, (xx, yy), (int(xx + u), int(yy + v)), (255, 0, 0), 2)
        cv2.circle(mask, (xx, yy), 1, (0, 255, 0), -1)

    return cv2.addWeighted(img, 0.3, mask, 0.7, 0)

def create_comparative_animation(pred_data, label_data, output_file):

    height, width = pred_data.shape[2], pred_data.shape[3]
    width = width * 2
    out = cv2.VideoWriter(output_file, cv2.VideoWriter_fourcc(*'mp4v'), 10, (width, height))

    for i in range(pred_data.shape[0]):
        pred_flow = pred_data[i].transpose(1, 2, 0)
        label_flow = label_data[i].transpose(1, 2, 0)
        blank_image = np.zeros((height, width, 3), dtype=np.uint8)
        flow_img = draw_flows(blank_image, pred_flow, label_flow)
        out.write(flow_img)
    out.release()

create_comparative_animation(predictions_np, original_labels_np, 'comparative_flow_animation.mp4')

"""Computational load to train just 88 samples, batches of 2 with spatial dimensions of 1080 by 575, elevate them to a higher dimension of size 32, and select top and bottom 6 modes from the spectral distribution. Accomplished using Google Compute Engine TPU with High RAM.

![RAM&Disk.png](data:image/png;base64,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)
"""